	
import chisel3._
import chisel3.util.BitPat

object Instructions {

    val default = (0 until 7).map( _ => 0.U ).toList

    // IMM SEL
    val IMM_N = 0.U(1.W)
    val IMM_Y = 1.U(1.W)
    // BR EN
    val BR_N = 0.U(1.W)
    val BR_Y = 1.U(1.W)
    // LD EN
    val LD_N = 0.U(1.W)
    val LD_Y = 1.U(1.W)
    // ST EN
    val ST_N = 0.U(1.W)
    val ST_Y = 1.U(1.W)
    // WB TYPE
    val WB_ALU = 0.U(1.W)
    val WB_MEM = 1.U(1.W)
    // WR EN
    val WB_N = 0.U(1.W)
    val WB_Y = 1.U(1.W)
    
    // FIXME: LW - SW format and IMM_EN
    // SIGNED / UNSGINED FIX

    val map = Array(
        //            alu_op    imm_en   br_en    ld_en    st_en   wb_type   wb_en
        // Arithmetic
        ADD ->   List(ALU.add,  IMM_N,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        ADDI ->  List(ALU.add,  IMM_Y,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        SUB ->   List(ALU.sub,  IMM_N,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        // Logical
        AND ->   List(ALU.and,  IMM_N,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        ANDI ->  List(ALU.and,  IMM_Y,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        OR ->    List(ALU.or,   IMM_N,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        ORI ->   List(ALU.or,   IMM_Y,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        XOR ->   List(ALU.xor,  IMM_N,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        XORI ->  List(ALU.xor,  IMM_Y,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        // Shifts
        SLLV ->  List(ALU.sll, IMM_N,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        SLLI ->  List(ALU.sll,  IMM_Y,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        SRLV ->  List(ALU.srl, IMM_N,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        // Compare
        SLT ->   List(ALU.lt,   IMM_N,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        SLTI ->  List(ALU.lt,   IMM_Y,   BR_N,    LD_N,    ST_N,   WB_ALU,   WB_Y),
        // Branch
        BNE ->   List(ALU.ne,   IMM_N,   BR_Y,    LD_N,    ST_N,   WB_ALU,   WB_N),
        BEQ ->   List(ALU.eq,   IMM_N,   BR_Y,    LD_N,    ST_N,   WB_ALU,   WB_N),
        BLT ->   List(ALU.lt,   IMM_N,   BR_Y,    LD_N,    ST_N,   WB_ALU,   WB_N),
        BGE ->   List(ALU.ge,   IMM_N,   BR_Y,    LD_N,    ST_N,   WB_ALU,   WB_N),
        // Load
        LW ->    List(ALU.add,  IMM_N,   BR_N,    LD_Y,    ST_N,   WB_MEM,   WB_Y),
        // Store
        SW ->    List(ALU.add,  IMM_N,   BR_N,    LD_N,    ST_Y,   WB_ALU,   WB_N),
    )

    // TODO: add unsigned arithmetic ?
    // Arithmetic
    def ADDI  = BitPat("b001000??????????????????????????")
    def ADD   = BitPat("b000000???????????????00000100000")
    def SUB   = BitPat("b000000???????????????00000100010")
    // Logical
    def AND   = BitPat("b000000???????????????00000100100")
    def ANDI  = BitPat("b001100??????????????????????????")
    def OR    = BitPat("b000000???????????????00000100101")
    def ORI   = BitPat("b001101??????????????????????????")
    def XOR   = BitPat("b000000???????????????00000100110")
    def XORI  = BitPat("b001110??????????????????????????")
    // Shift
    def SLLV  = BitPat("b00000000000???????????????000000")
    def SLLI  = BitPat("b010000??????????????????????????") // different than MIPS
    def SRLV  = BitPat("b00000000000???????????????000010")
    // Compare
    def SLT   = BitPat("b000000???????????????00000101010")
    def SLTI  = BitPat("b010010??????????????????????????")
    // Branch
    def BEQ   = BitPat("b000100??????????????????????????")
    def BNE   = BitPat("b000101??????????????????????????")
    def BLT   = BitPat("b000110??????????????????????????")
    def BGE   = BitPat("b000111??????????????????????????")
    // Mem
    def LW    = BitPat("b100011??????????????????????????")
    def SW    = BitPat("b101011??????????????????????????")

    /*
    // Jump & Link
    def JAL = BitPat("b?????????????????????????1101111")
    def JALR = BitPat("b?????????????????000?????1100111")
    // NOP
    def NOP = BitPat.bitPatToUInt(BitPat("b00000000000000000000000000010011"))*/
}
