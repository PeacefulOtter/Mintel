
import chisel3._
import chisel3.util.BitPat
import instr.InstructionFormats.{I, J, R}

object Instructions {
    // i-format
    def I_RS = 6.U(5.W)
    def I_RT = 11.U(5.W)
    def I_IMM = 16.U(16.W)

    // j-format
    def J_ADDR = 6.U(26.W)

    // r-format
    def R_RS = 6.U(5.W)
    def R_RT = 11.U(5.W)
    def R_RD = 16.U(5.W)
    def R_FUNCT = 26.U(6.W)

    def X = 0.U(0.W);

    // IMM SEL
    def IMM_X = 0.U(1.W)
    def IMM_EN = 1.U(1.W)

    // WB SEL
    def WB_ALU = 0.U(1.W)
    def WB_MEM = 1.U(1.W)

    def conversion = Map(
        //         rs      rt      rd     imm      addr     funct    imm_sel
        I -> List( I_RS,  I_RT,    X,     I_IMM,   X,       X,       IMM_EN),
        J -> List( X,     X,       X,     X,       J_ADDR,  X,       IMM_X),
        R -> List( R_RS,  R_RT,    R_RD,  X,       X,       R_FUNCT, IMM_X)
    )

    def default= List(X, X, X, X, X, X, X, X)

    // BR TYPE
    def BR_X = 0.U(3.W)
    def BR_LTU = 1.U(3.W)
    def BR_LT = 2.U(3.W)
    def BR_EQ = 3.U(3.W)
    def BR_GEU = 4.U(3.W)
    def BR_GE = 5.U(3.W)
    def BR_NE = 6.U(3.W)

    // LD TYPE
    val LD_X = 0.U(1.W)
    val LD_LW = 1.U(1.W)

    // ST TYPE
    val ST_X = 0.U(1.W)
    val ST_W = 1.U(1.W)

    // WR EN
    def WB_N = 0.U(1.W) // no
    def WB_Y = 1.U(1.W) // yes

    val map = Array(
        //       type  alu_op    ld_type   st_type  wb_type  wb_en
        // Arithmetic
        ADD ->   (R,    ALU.add,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        ADDI ->  (I,    ALU.add,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        SUB ->   (R,    ALU.sub,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        // Logical
        AND ->   (R,    ALU.and,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        ANDI ->  (I,    ALU.and,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        OR ->    (R,    ALU.or,   LD_X,     ST_X,   WB_ALU,   WB_Y),
        ORI ->   (I,    ALU.or,   LD_X,     ST_X,   WB_ALU,   WB_Y),
        XOR ->   (R,    ALU.xor,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        XORI ->  (I,    ALU.xor,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        // Shifts
        SLL ->   (R,    ALU.sll,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        SLLI ->  (I,    ALU.sll,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        SRL ->   (R,    ALU.srl,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        SRLI ->  (I,    ALU.srl,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        // Compare
        SLT ->   (R,    ALU.lt,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        SLTI ->  (I,    ALU.lt,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        SLTU ->  (R,    ALU.ltu,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        SLTIU -> (I,   ALU.ltu,  LD_X,     ST_X,   WB_ALU,   WB_Y),
        // Branch
        BEQ ->   (J,    ALU.eq,   LD_X,     ST_X,   WB_ALU,   WB_N),
        BNE ->   (J,    ALU.ne,   LD_X,     ST_X,   WB_ALU,   WB_N),
        BLT ->   (J,    ALU.lt,   LD_X,     ST_X,   WB_ALU,   WB_N),
        BGE ->   (J,    ALU.ge,   LD_X,     ST_X,   WB_ALU,   WB_N),
        BLTU ->  (J,    ALU.ltu,  LD_X,     ST_X,   WB_ALU,   WB_N),
        BGEU ->  (J,    ALU.geu,  LD_X,     ST_X,   WB_ALU,   WB_N),
        // Load
        LW ->    (R,    ALU.add,  LD_X,     ST_X,   WB_MEM,   WB_Y),
        // Store
        SW ->    (R,    ALU.add,  LD_X,     ST_W,   WB_ALU,   WB_N),
    ).map((line) => (line._1, conversion.get(line._2._1).get))

    // Arithmetic
    def ADD = BitPat("b0000000??????????000?????0110011")
    def ADDI = BitPat("b?????????????????000?????0010011")
    def SUB = BitPat("b0100000??????????000?????0110011")
    // Logical
    def AND = BitPat("b0000000??????????111?????0110011")
    def ANDI = BitPat("b?????????????????111?????0010011")
    def OR = BitPat("b0000000??????????110?????0110011")
    def ORI = BitPat("b?????????????????110?????0010011")
    def XOR = BitPat("b0000000??????????100?????0110011")
    def XORI = BitPat("b?????????????????100?????0010011")
    // Shift
    def SLL = BitPat("b0000000??????????001?????0110011")
    def SLLI = BitPat("b0000000??????????001?????0010011")
    def SRL = BitPat("b0000000??????????101?????0110011")
    def SRLI = BitPat("b0000000??????????101?????0010011")
    // Compare
    def SLT = BitPat("b0000000??????????010?????0110011")
    def SLTI = BitPat("b?????????????????010?????0010011")
    def SLTU = BitPat("b0000000??????????011?????0110011")
    def SLTIU = BitPat("b?????????????????011?????0010011")
    // Branch
    def BEQ = BitPat("b?????????????????000?????1100011")
    def BNE = BitPat("b?????????????????001?????1100011")
    def BLT = BitPat("b?????????????????100?????1100011")
    def BGE = BitPat("b?????????????????101?????1100011")
    def BLTU = BitPat("b?????????????????110?????1100011")
    def BGEU = BitPat("b?????????????????111?????1100011")
    // Load
    def LW = BitPat("b?????????????????010?????0000011")
    // Store
    def SW = BitPat("b?????????????????010?????0100011")


    // val instr = BitPat("b00000000000000000001000001100011")
    // instr.cover( BNE._2 )

    // Loads
    """ def LB = Instructions( InstructionFormats.R, BitPat("b?????????????????000?????0000011") )
    def LH = BitPat("b?????????????????001?????0000011")
    def LW = BitPat("b?????????????????010?????0000011")
    def LBU = BitPat("b?????????????????100?????0000011")
    def LHU = BitPat("b?????????????????101?????0000011")
    // Stores
    def SB = BitPat("b?????????????????000?????0100011")
    def SH = BitPat("b?????????????????001?????0100011")
    def SW = BitPat("b?????????????????010?????0100011")
    // Shifts
    def SLL = BitPat("b0000000??????????001?????0110011")
    def SLLI = BitPat("b0000000??????????001?????0010011")
    def SRL = BitPat("b0000000??????????101?????0110011")
    def SRLI = BitPat("b0000000??????????101?????0010011")
    def SRA = BitPat("b0100000??????????101?????0110011")
    def SRAI = BitPat("b0100000??????????101?????0010011")
    // Arithmetic
    def ADD = BitPat("b0000000??????????000?????0110011")
    def ADDI = BitPat("b?????????????????000?????0010011")
    def SUB = BitPat("b0100000??????????000?????0110011")
    def LUI = BitPat("b?????????????????????????0110111")
    def AUIPC = BitPat("b?????????????????????????0010111")
    // Logical
    def XOR = BitPat("b0000000??????????100?????0110011")
    def XORI = BitPat("b?????????????????100?????0010011")
    def OR = BitPat("b0000000??????????110?????0110011")
    def ORI = BitPat("b?????????????????110?????0010011")
    def AND = BitPat("b0000000??????????111?????0110011")
    def ANDI = BitPat("b?????????????????111?????0010011")
    // Compare
    def SLT = BitPat("b0000000??????????010?????0110011")
    def SLTI = BitPat("b?????????????????010?????0010011")
    def SLTU = BitPat("b0000000??????????011?????0110011")
    def SLTIU = BitPat("b?????????????????011?????0010011")
    // Branches
    def BEQ = BitPat("b?????????????????000?????1100011")
    def BNE = BitPat("b?????????????????001?????1100011")
    def BLT = BitPat("b?????????????????100?????1100011")
    def BGE = BitPat("b?????????????????101?????1100011")
    def BLTU = BitPat("b?????????????????110?????1100011")
    def BGEU = BitPat("b?????????????????111?????1100011")
    // Jump & Link
    def JAL = BitPat("b?????????????????????????1101111")
    def JALR = BitPat("b?????????????????000?????1100111")
    // Synch
    def FENCE = BitPat("b0000????????00000000000000001111")
    def FENCEI = BitPat("b00000000000000000001000000001111")
    // CSR Access
    def CSRRW = BitPat("b?????????????????001?????1110011")
    def CSRRS = BitPat("b?????????????????010?????1110011")
    def CSRRC = BitPat("b?????????????????011?????1110011")
    def CSRRWI = BitPat("b?????????????????101?????1110011")
    def CSRRSI = BitPat("b?????????????????110?????1110011")
    def CSRRCI = BitPat("b?????????????????111?????1110011")
    // Change Level
    def ECALL = BitPat("b00000000000000000000000001110011")
    def EBREAK = BitPat("b00000000000100000000000001110011")
    def ERET = BitPat("b00010000000000000000000001110011")
    def WFI = BitPat("b00010000001000000000000001110011")

    def NOP = BitPat.bitPatToUInt(BitPat("b00000000000000000000000000010011"))"""
}
